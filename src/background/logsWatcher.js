const fs = require('fs')
const path = require('path')
const { ipcMain } = require('electron')
const { fileResolve } = require('./tools/fileSystem')
const {isRunning, cloneFrom, findLastIndex } = require('./tools/methods')
const syncApp = require('./sync').syncApp
const dataFolder = path.resolve(process.cwd(), 'datas')
const moment = require('moment')
const characters = require('./jsons/characters.json')
const items = require('./jsons/items.json')
const floors = require('./jsons/floors.json')
const splitLines = /[\r\n]+/g
const repentanceFolderPath = `${process.env.USERPROFILE}\\Documents\\My Games\\Binding of Isaac Repentance`
const repentanceLogsFile = `${repentanceFolderPath}\\log.txt`
const runsJsonPath = `${dataFolder}\\runs.json`
let runs, repentanceLogs, currentRun, currentRunInit, currentCharater, currentCharater2, currentFloor, currentCurse, currentGameState, currentGameMode, logsLastReadLines, win
let repentanceIsLaunched = false
let inRun = false
// let backToMenu = false
let firstInit = false

function getCharater(string) {
    return cloneFrom(characters.find(character => character.id === string.split(" ")[9]))
}

function getSeed(string) {
    return {
        seed: `${string.split(" ")[5]} ${string.split(" ")[6]}`
    }
}

function getFloor(string) {
    return cloneFrom(floors.stages.find(floor => floor.id === `${string.split(" ")[4].match(/\d+/)[0]}.${string.split(" ")[6]}`))
}

function getGameState(string) {
    return string.split(" ")[4]
}

function getCollectible(string, splitValue) {
    return {
        id: parseInt(string.split(" ")[splitValue]),
        title: items.collectibles.find(collectible => collectible.itemID === parseInt(string.split(" ")[splitValue])).title,
        itemType: items.collectibles.find(collectible => collectible.itemID === parseInt(string.split(" ")[splitValue])).itemType,
        category: items.collectibles.find(collectible => collectible.itemID === parseInt(string.split(" ")[splitValue])).category,
        removed: false
    }
}

function getRunEnd(string) {
    return {
        date: moment().unix(),
        win: string.includes("Game Over") ? false : true,
        killedBy: string.includes("Game Over") ? string.split(" ")[6].slice(1,-1) : null,
        spawnedBy: string.includes("Game Over") ? string.split(" ")[9].slice(1,-1) : null,
        damageFlags: string.includes("Game Over") ? string.split(" ")[12].slice(1,-1) : null
    }
}

function saveRunsToDisk() {
    fs.writeFile(runsJsonPath, JSON.stringify(runs), 'utf8', (err) => {if (err) throw err})
}

function removeRun(runId) {
    console.log(`Removing run : ${runId}...`)
    runIndex = runs.findIndex(run => run.id === runId)
    if(runIndex != -1) {
        syncApp(win,{trigger: "remove run", run: runs[runIndex].id})
        runs.splice(runIndex, 1)
        console.log(`Run : ${runId} was removed`)
        saveRunsToDisk()
    } else {
        console.log(`Impossible to find : ${runId}, this run doesn't exist on the backend ! (Sync issue ?)`)
    }
}

function checkPreviousRuns() {
    let deleted = false
    let sameGameStateAlreadyChecked = false
    const repentanceLogs = fs.readFileSync(repentanceLogsFile, "utf8")
    const repentanceLogsArray = repentanceLogs.split(splitLines)
    let seedsList = repentanceLogsArray.filter(v=>v.includes("RNG Start Seed"))
    const currentRunIndex = repentanceLogsArray.findIndex(line => line === seedsList[seedsList.length - 1])
    if ((runs[1] != undefined && runs[1].runEnd.date === null && runs[1].toRemove.checkedByUser === false)) {
        console.log("Unfinished directly previous run found, check if the current run was generated by a direct reset...")
        if (repentanceLogsArray[currentRunIndex - 2].includes("CPU time")) {
            console.log("Current run was generated from a direct reset, remove previous run")
            syncApp(win,{trigger: "remove run", run: runs[1].id})
            runs.splice(1, 1)
            deleted = true
        } else console.log("Run was not directly generated, check if same game state...")
        if (!deleted && runs[1].gameState === currentGameState) {
            console.log("Current run was generated over an unfinished run on the same game state, ask user if he wants to remove it")
            runs[1].toRemove.status = true
            sameGameStateAlreadyChecked = true
            syncApp(win,{trigger: "ask remove run", run: [runs[1]]})
        } else console.log("Previous run is not from the same game state")
        if (!sameGameStateAlreadyChecked) {
            console.log("Check saved runs matching the current game state...")
            let unfinishedRuns = runs.filter(run => {
                if(run.id != runs[0].id && run.runEnd.date === null && run.gameState === currentGameState && run.toRemove.checkedByUser === false) return run
            })
            if (unfinishedRuns != undefined && unfinishedRuns.length > 0) {
                console.log("Unfinished runs found on the current game state, ask user if he wants to remove them")
                unfinishedRuns.forEach(run => run.toRemove.status = true)
                syncApp(win,{trigger: "ask remove run", run: unfinishedRuns})
            }
        }
    }
}

function isSameRun(seed) {
    if (!inRun) inRun = true
    //if (backToMenu) backToMenu = false
    return runs.find(function(run, i) {
        console.log(`compare run ${run.seed} id with current ${seed} id : compare run ${run.id} with current ${currentRun.id}`)
        if (currentRun.id === run.id) {
            return true
        }
        console.log(`compare run ${run.seed} with current ${seed} : [${run.gameState} <-> ${currentGameState}] -> [compare ${run.characters[0].name} <-> ${currentCharater.name}], run end: ${run.runEnd.date}`)
        if (
            run.runEnd.date === null &&
            run.seed === seed &&
            run.gameState === currentGameState &&
            run.characters[0].name === currentCharater.name
            ) {
                console.log("Same run")
                return true
            }
        return false
    })
}

function updateRun(params = {}) {
    if (currentRun === null) return console.warn("Current seed empty !")
    if (!currentRunInit) return console.warn("Current seed is not init !")
    const sameRun = isSameRun(currentRun.seed)
    if (sameRun) {
        console.log('Seed exists, check...')
        if(sameRun.runEnd.date === null) {
            console.log('Update current run...')
            if(currentRun.id === undefined) currentRun.id = sameRun.id
            switch (params.trigger) {
                case 'level init':
                    sameRun.floors.push(currentFloor)
                    break
                case 'game mode':
                    if (!sameRun.gameMode) {
                        const gameMode = params.log.includes("copy") ? "greed" : "normal"
                        sameRun.gameMode = gameMode
                    }
                    break
                case 'init other player':
                    if (!params.character.ignore) sameRun.characters.push(params.character)
                    break
                case 'adding collectible':
                    if (!sameRun.floors[sameRun.floors.length - 1].itemsCollected) {
                        sameRun.floors[sameRun.floors.length - 1].itemsCollected = []
                        sameRun.floors[sameRun.floors.length - 1].itemsCollected.push(params.collectible)
                    } 
                    else {
                        const foundItem = sameRun.floors.map((floor, index) => {
                            const itemIndex = floor.itemsCollected ? floor.itemsCollected.findIndex(item => item.id === params.collectible.id) : -1
                            return {
                                floorIndex: index,
                                itemIndex: itemIndex,
                                itemType: itemIndex >= 0 ? floor.itemsCollected[itemIndex].itemType : null,
                                itemRemoved: itemIndex >= 0 ? floor.itemsCollected[itemIndex].removed : null,
                                itemsNumber: itemIndex >= 0 ? floor.itemsCollected[itemIndex].number : 0
                            }
                        }).filter(item => item.itemIndex > -1)
                        console.log(foundItem[foundItem.length - 1])
                        if (foundItem.length > 0) {
                            if (foundItem[foundItem.length - 1].itemRemoved === true) {
                                sameRun.floors[foundItem[foundItem.length - 1].floorIndex].itemsCollected[foundItem[foundItem.length - 1].itemIndex].number = 1
                                sameRun.floors[foundItem[foundItem.length - 1].floorIndex].itemsCollected[foundItem[foundItem.length - 1].itemIndex].removed = false
                            } else {
                                sameRun.floors[foundItem[foundItem.length - 1].floorIndex].itemsCollected[foundItem[foundItem.length - 1].itemIndex].number += 1
                            }
                        }
                        else {
                            params.collectible.number = 1
                            sameRun.floors[sameRun.floors.length - 1].itemsCollected.push(params.collectible)
                        }
                    }
                    break
                case 'removing collectible':
                    const foundItem = sameRun.floors.map((floor, index) => {
                        const itemIndex = floor.itemsCollected ? floor.itemsCollected.findIndex(item => item.id === params.collectible.id) : -1
                        return {
                            floorIndex: index,
                            itemIndex: itemIndex,
                            itemType: itemIndex >= 0 ? floor.itemsCollected[itemIndex].itemType : null,
                            itemRemoved: itemIndex >= 0 ? floor.itemsCollected[itemIndex].removed : null,
                            itemsNumber: itemIndex >= 0 ? floor.itemsCollected[itemIndex].number : 0
                        }
                    }).filter(item => item.itemIndex > -1)
                    console.log(foundItem[foundItem.length - 1])
                    if (foundItem.length > 0) {
                        if (foundItem[foundItem.length - 1].itemRemoved === false && foundItem[foundItem.length - 1].itemsNumber > 0) {
                            if(foundItem[foundItem.length - 1].itemsNumber === 1) {
                                sameRun.floors[foundItem[foundItem.length - 1].floorIndex].itemsCollected[foundItem[foundItem.length - 1].itemIndex].number = 0
                                sameRun.floors[foundItem[foundItem.length - 1].floorIndex].itemsCollected[foundItem[foundItem.length - 1].itemIndex].removed = true
                            } else if (foundItem[foundItem.length - 1].itemsNumber > 1) {
                                sameRun.floors[foundItem[foundItem.length - 1].floorIndex].itemsCollected[foundItem[foundItem.length - 1].itemIndex].number += -1
                            }
                        }
                    }
                    break
                case 'run end':
                    if (sameRun.runEnd.date === null) {
                        const runEnd = getRunEnd(params.log)
                        sameRun.runEnd.date = runEnd.date
                        sameRun.runEnd.win = runEnd.win
                        sameRun.runEnd.killedBy = runEnd.killedBy
                        sameRun.runEnd.spawnedBy = runEnd.spawnedBy
                        sameRun.runEnd.damageFlags = runEnd.damageFlags
                        if (!sameRun.runEnd.win) sameRun.floors[sameRun.floors.length - 1].death = true
                    }
                    break
                default:
                    return false
            }
            sameRun.runUpdate = moment().unix()
            runs[sameRun.id] = sameRun
            syncApp(win,{trigger: "update run", run: sameRun})
        } else {
            console.log('Run is over')
        }
    }
    else {
        console.log('Create a run...')
        currentRun.id = `${currentRun.seed} ${moment().unix()}`
        const run = {
            id: currentRun.id,
            customName: null,
            seed: currentRun.seed,
            gameState: currentGameState,
            gameMode: currentGameMode,
            runStart: moment().unix(),
            runUpdate: moment().unix(),
            runEnd: {
                date: null,
                win: null,
                killedBy: null,
                spawnedBy: null,
                damageFlags: null
            },
            characters: [currentCharater],
            floors: [currentFloor],
            toRemove: {
                status: false,
                checkedByUser: false
            }
        }
        console.log(run)
        runs.unshift(run)
        syncApp(win,{trigger: "create run", run: run})
        console.log("New run generated checking previous runs...")
        checkPreviousRuns()
    }
}

function parseLogs(newLogs, logArray) {
    newLogs.forEach(log => {
        if(log.includes("Loading GameState")) {
            console.log(log)
            currentGameState = getGameState(log)
        }
        if(log.includes("Initialized player")) {
            console.log(log)
            if(!currentCharater && !currentRunInit) currentCharater = getCharater(log)
            else if (currentRunInit) {
                updateRun({trigger: "init other player", character: getCharater(log)})
            }
        }
        if(log.includes("RNG Start Seed")) {
            console.log(log)
            currentRunInit = false
            currentRun = getSeed(log)
        }
        if(log.includes("Level::Init")) {
            console.log(log)
            currentCurse = logArray[logArray.lastIndexOf(log) + 1].includes("Curse") ? logArray[logArray.lastIndexOf(log) + 1].split(" ").slice(2).join(" ") : null
            currentFloor = getFloor(log)
            if (currentCurse) currentFloor.curse = currentCurse
            updateRun({trigger: "level init"})
        }
        // if(log.includes("Curse")) {
        //     currentCurse = logArray[logArray.lastIndexOf(log) + 1].split(" ").slice(2).join(" ")
        //     currentFloor.curse = currentCurse
        //     updateRun({trigger: "curse"})
        // }
        if(log.includes("generated rooms")) {
            if (!currentRunInit) {
                console.log(log)
                currentRunInit = true
                updateRun({trigger: "generated rooms"})
            }
        }
        if(log.split(' ')[2] === "Room") {
            if (!currentGameMode) {
                console.log(log)
                updateRun({trigger: "game mode", log: log})
            }
        }
        if(log.includes("Adding collectible")) {
            console.log(log)
            updateRun({trigger: "adding collectible", collectible: getCollectible(log, 4)})
            saveRunsToDisk()
        }
        if(log.includes("Removing voided collectible")) {
            console.log(log)
            updateRun({trigger: "removing collectible", collectible: getCollectible(log, 5)})
            saveRunsToDisk()
        }
        if(log.includes("Game Over") || (log.includes("playing cutscene") && !log.includes("Intro") && !log.includes("Credits") && !log.includes("Dogma"))) {
            console.log(log)
            updateRun({trigger: "run end", log: log})
            currentRunInit = false
            currentRun = null
            currentCharater = null
            currentFloor = null
            currentCurse = null
            saveRunsToDisk()
        }
        if(log.includes("Menu Game Init")) {
            console.log(log)
            inRun = false
            //backToMenu = true
            currentRunInit = false
            currentRun = null
            currentCharater = null
            currentFloor = null
            currentCurse = null
            currentGameMode = null
        }
    })
}

function watchRepentanceLogs() {
    fs.watchFile(repentanceLogsFile,{interval: 500},
        () => {
            const log = fs.readFileSync(repentanceLogsFile, "utf8")
            const logArray = log.split(splitLines)
            const lines = logArray.filter(v=>v!='').length
            const diff = lines - logsLastReadLines
            if (diff <= 0) return
            const newLogs = logArray.filter(v=>v!='').splice(- diff)
            parseLogs(newLogs, logArray)
            //console.log(diff,logsLastReadLines,lines)
            logsLastReadLines = lines
        }
    )
}

function unWatchRepentanceLogs() {
    fs.unwatchFile(repentanceLogsFile)
}

async function init() {
    const loadRuns = await fileResolve(dataFolder, 'runs.json', '[]')
    runs = JSON.parse(fs.readFileSync(loadRuns))
    currentRunInit = false
    repentanceLogs = fs.readFileSync(repentanceLogsFile, "utf8")
    repentanceLogsArray = repentanceLogs.split(splitLines)
    let gameStatesList = repentanceLogsArray.filter(v=>v.includes("Loading GameState"))
    currentGameState = gameStatesList[gameStatesList.length - 1] != undefined ? getGameState(gameStatesList[gameStatesList.length - 1]) : null
    let seedsList = repentanceLogsArray.filter(v=>v.includes("RNG Start Seed"))
    if (seedsList[seedsList.length - 1] != undefined) {
        console.log("Seeds exist in current logs, checking...")
        const lastLogs = repentanceLogsArray.slice(findLastIndex(repentanceLogsArray, seedsList[seedsList.length - 1]), repentanceLogsArray.length - 1)
        inRun = lastLogs.filter(v=>v.includes("Menu Game Init")).length < 1 && lastLogs.filter(v=>v.includes("Game Over")).length < 1 && lastLogs.filter(v=>v.includes("playing cutscene")).length < 1
        console.log("Currently in run :", inRun)
        if (inRun) {
            parseLogs(lastLogs, repentanceLogsArray)
        }
    }
    
    logsLastReadLines = repentanceLogsArray.filter(v=>v!='').length
    if(!firstInit) firstInit = true
    //console.log('init values : ', currentRun, currentCharater, currentFloor)
}

ipcMain.on('USER_EDIT_RUN', (event, payload) => {
    console.log(payload)
})

ipcMain.on('USER_REMOVE_RUN', (event, payload) => {
    console.log(`User wants to remove run : ${payload}`)
    removeRun(payload)
})

module.exports = {
    startLogsWatch: function(window) {
        win = window
        setInterval(() => {
            isRunning('isaac-ng.exe', (status) => {
                if (!status && repentanceIsLaunched) {
                    console.log("unwatch logs")
                    repentanceIsLaunched = false
                    unWatchRepentanceLogs()
                    saveRunsToDisk()
                    syncApp(win,{trigger: "logs watch status", watching: false})
                } else if (status && !repentanceIsLaunched) {
                    console.log("Waiting for logs...")
                    repentanceIsLaunched = true
                    setTimeout(() => {
                        console.log("Watching logs")
                        init()
                        watchRepentanceLogs()
                        syncApp(win,{trigger: "logs watch status", watching: true})
                    }, 10000)
                }
            })
        }, 1000)
    }
}