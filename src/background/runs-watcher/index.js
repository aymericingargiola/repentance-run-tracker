const fs = require('fs')
const path = require('path')
const { ipcMain } = require('electron')
const { getOptions, getModPath, getCharater, getSeed, getFloor, getGameState, getCollectible, getTrinket, getRunEnd, getRunDuration, saveFileToDisk, removeRun } = require('./helpers')
const { fileResolve } = require('../tools/fileSystem')
const { isRunning, findLastIndex } = require('../tools/methods')
const { syncApp } = require('../sync')
const dataFolder = path.resolve(process.cwd(), 'datas')
const moment = require('moment')
const splitFormat = /[\r\n]+/g
const repentanceFolderPath = `${process.env.USERPROFILE}\\Documents\\My Games\\Binding of Isaac Repentance`
const repentanceLogsFile = `${repentanceFolderPath}\\log.txt`
const repentanceOptionsFile = `${repentanceFolderPath}\\options.ini`
const runsJsonPath = `${dataFolder}\\runs.json`
const configJsonPath = `${dataFolder}\\config.json`
let watchingLogs, config, runs, repentanceLogs, repentanceOptions, currentRun, currentRunInit, currentCharater, currentCharater2, currentFloor, currentCurse, currentGameState, currentGameMode, logsLastReadLines, win
let repentanceIsLaunched = false
let inRun = false
let firstInit = false
// let backToMenu = false
let extendedSaveMode = false //This variable can be used later to save more informations (Stats, bombs, coins, time...), with the help of a mod or game memory reading
let otherModLoaded = false

function checkPreviousRuns() {
    let deleted = false
    let sameGameStateAlreadyChecked = false
    const repentanceLogs = fs.readFileSync(repentanceLogsFile, "utf8")
    const repentanceLogsArray = repentanceLogs.split(splitFormat)
    let seedsList = repentanceLogsArray.filter(v=>v.includes("RNG Start Seed"))
    const currentRunIndex = repentanceLogsArray.findIndex(line => line === seedsList[seedsList.length - 1])
    if ((runs[1] != undefined && runs[1].runEnd.date === null && runs[1].toRemove.checkedByUser === false)) {
        console.log("Unfinished directly previous run found, check if the current run was generated by a direct reset...")
        if (repentanceLogsArray[currentRunIndex - 2].includes("CPU time")) {
            console.log("Current run was generated from a direct reset, remove previous run")
            syncApp(win,{trigger: "remove run", run: runs[1].id})
            runs.splice(1, 1)
            currentCharater = null
            currentFloor = null
            currentCurse = null
            deleted = true
        } else console.log("Run was not directly generated, check if same game state...")
        if (!deleted && runs[1].gameState === currentGameState) {
            console.log("Current run was generated over an unfinished run on the same game state, ask user if he wants to remove it")
            runs[1].toRemove.status = true
            sameGameStateAlreadyChecked = true
            syncApp(win,{trigger: "ask remove run", run: [runs[1]]})
        } else console.log("Previous run is not from the same game state")
        if (!sameGameStateAlreadyChecked) {
            console.log("Check saved runs matching the current game state...")
            let unfinishedRuns = runs.filter(run => {
                if(run.id != runs[0].id && run.runEnd.date === null && run.gameState === currentGameState && run.toRemove.checkedByUser === false) return run
            })
            if (unfinishedRuns != undefined && unfinishedRuns.length > 0) {
                console.log("Unfinished runs found on the current game state, ask user if he wants to remove them")
                unfinishedRuns.forEach(run => run.toRemove.status = true)
                syncApp(win,{trigger: "ask remove run", run: unfinishedRuns})
            }
        }
    }
}

function isSameRun(seed) {
    if (!inRun) inRun = true
    return runs.find(function(run, i) {
        console.log(`compare run ${run.seed} id with current ${seed} id : compare run ${run.id} with current ${currentRun.id}`)
        if (currentRun.id === run.id) {
            return true
        }
        console.log(`compare run ${run.seed} with current ${seed} : [${run.gameState} <-> ${currentGameState}] -> [compare ${run.characters[0].name} <-> ${currentCharater.name}], run end: ${run.runEnd.date}`)
        if (
            run.runEnd.date === null &&
            run.seed === seed &&
            run.gameState === currentGameState &&
            run.characters[0].name === currentCharater.name
            ) {
                console.log("Same run")
                return true
            }
        return false
    })
}

function collectibleManager(sameRun, collectible, status) {
    const playerContext = collectible.player

    // add itemsCollected key on last floor if doesn't exist
    if (!sameRun.floors[sameRun.floors.length - 1].itemsCollected) sameRun.floors[sameRun.floors.length - 1].itemsCollected = []

    // add activables key to context player if doesn't exist and if current collectible is an activable
    if (collectible.itemType === "Active" && !sameRun.characters[playerContext].activables) sameRun.characters[playerContext].activables = []

    // return a filtered array with matching item
    const foundItem = sameRun.floors.map((floor, index) => {
        const itemIndex = floor.itemsCollected ? floor.itemsCollected.findIndex(item => item.id === collectible.id) : -1
        return {
            floorIndex: index,
            itemIndex: itemIndex,
            itemPlayer: itemIndex > -1 ? floor.itemsCollected[itemIndex].player : null,
            itemType: itemIndex > -1 ? floor.itemsCollected[itemIndex].itemType : null,
            itemRemoved: itemIndex > -1 ? floor.itemsCollected[itemIndex].removed : null,
            itemsNumber: itemIndex > -1 ? floor.itemsCollected[itemIndex].number : 0
        }
    }).filter(item => item.itemIndex > -1)

    // check if at least one item is matching
    if (foundItem.length > 0) {
        const lastFoundItem = foundItem[foundItem.length - 1]
        switch (status) {
            case 'add':
                if (lastFoundItem.itemRemoved === true) {
                    sameRun.floors[lastFoundItem.floorIndex].itemsCollected[lastFoundItem.itemIndex].number = 1
                    sameRun.floors[lastFoundItem.floorIndex].itemsCollected[lastFoundItem.itemIndex].removed = false
                } else {
                    sameRun.floors[lastFoundItem.floorIndex].itemsCollected[lastFoundItem.itemIndex].number += 1
                }
                if (lastFoundItem.itemType === "Active") {
                    sameRun.characters[playerContext].activables.push(sameRun.floors[lastFoundItem.floorIndex].itemsCollected[lastFoundItem.itemIndex])
                }
            case 'remove':
                if (lastFoundItem.itemRemoved === false && lastFoundItem.itemsNumber > 0) {
                    if(lastFoundItem.itemsNumber === 1) {
                        sameRun.floors[lastFoundItem.floorIndex].itemsCollected[lastFoundItem.itemIndex].number = 0
                        sameRun.floors[lastFoundItem.floorIndex].itemsCollected[lastFoundItem.itemIndex].removed = true
                    } else if (lastFoundItem.itemsNumber > 1) {
                        sameRun.floors[foundItem[foundItem.length - 1].floorIndex].itemsCollected[foundItem[foundItem.length - 1].itemIndex].number += -1
                    }
                    if (lastFoundItem.itemType === "Active") {
                        const itemToRemoveIndex = sameRun.characters[playerContext].activables.findIndex(item => item.id === collectible.id)
                        sameRun.characters[playerContext].activables.splice(itemToRemoveIndex, 1)
                    }
                }
        }
    }

    // if no item found, create a new one if the status is on "add"
    else if (status === 'add') {
        collectible.number = 1
        sameRun.floors[sameRun.floors.length - 1].itemsCollected.push(collectible)
        if (collectible.itemType === "Active") sameRun.characters[playerContext].activables.push(collectible)
    }
}

function updateOrCreateRun(params = {}) {
    if (currentRun === null) return console.warn("Current seed empty !")
    if (!currentRunInit) return console.warn("Current seed is not init !")
    const sameRun = isSameRun(currentRun.seed)
    if (sameRun) {
        console.log('Seed exists, check...')
        if(sameRun.runEnd.date === null) {
            console.log('Update current run...')
            if(currentRun.id === undefined) currentRun.id = sameRun.id
            switch (params.trigger) {
                case 'level init':
                    sameRun.floors.push(currentFloor)
                    break
                case 'game mode':
                    if (!sameRun.gameMode) {
                        const gameMode = params.log.includes("copy") ? "greed" : "normal"
                        sameRun.gameMode = gameMode
                    }
                    currentGameMode = sameRun.gameMode
                    break
                case 'init other player':
                    if (params.character && !params.character.ignore) sameRun.characters.push(params.character)
                    break
                case 'adding collectible':
                    collectibleManager(sameRun, params.collectible, "add")
                    break
                case 'removing collectible':
                    collectibleManager(sameRun, params.collectible, "remove")
                    break
                case 'run end':
                    if (sameRun.runEnd.date === null) {
                        const runEndInfo = getRunEnd(params.log)
                        sameRun.runEnd.date = runEndInfo.date
                        sameRun.runEnd.win = runEndInfo.win
                        sameRun.runEnd.killedBy = runEndInfo.killedBy
                        sameRun.runEnd.spawnedBy = runEndInfo.spawnedBy
                        sameRun.runEnd.damageFlags = runEndInfo.damageFlags
                        sameRun.runDuration = getRunDuration(moment.unix(runEndInfo.date), moment.unix(sameRun.runStart))
                        if (!sameRun.runEnd.win) sameRun.floors[sameRun.floors.length - 1].death = true
                    }
                    break
                default:
                    return false
            }
            sameRun.runUpdate = moment().unix()
            runs[sameRun.id] = sameRun
            syncApp(win,{trigger: "update run", run: sameRun})
        } else {
            console.log('Run is over')
        }
    }
    else {
        console.log('Create a run...')
        currentRun.id = `${currentRun.seed} ${moment().unix()}`
        const run = {
            id: currentRun.id,
            customName: null,
            seed: currentRun.seed,
            gameState: currentGameState,
            gameMode: currentGameMode,
            gameOptions: repentanceOptions,
            runStart: moment().unix(),
            runUpdate: moment().unix(),
            runUserUpdate: null,
            runEnd: {
                date: null,
                win: null,
                killedBy: null,
                spawnedBy: null,
                damageFlags: null
            },
            runDuration: null,
            characters: [currentCharater],
            floors: [currentFloor],
            toRemove: {
                status: false,
                checkedByUser: false
            },
            extendedSaveMode: extendedSaveMode,
            otherModLoaded: otherModLoaded
        }
        console.log(run)
        runs.unshift(run)
        syncApp(win,{trigger: "create run", run: run})
        console.log("New run generated checking previous runs...")
        checkPreviousRuns()
    }
}

//Parse Repentance logs file
function parseLogs(newLogs, logArray) {
    newLogs.forEach(log => {
        if(log.includes("Loading GameState")) {
            console.log(log)
            currentGameState = getGameState(log)
        }
        if(log.includes("Initialized player")) {
            console.log(log)
            if(!currentCharater && !currentRunInit) currentCharater = getCharater(log)
            else if (currentRunInit) {
                updateOrCreateRun({trigger: "init other player", character: getCharater(log)})
            }
        }
        if(log.includes("RNG Start Seed")) {
            console.log(log)
            currentRunInit = false
            currentRun = getSeed(log)
        }
        if(log.includes("Level::Init")) {
            console.log(log)
            currentCurse = logArray[logArray.lastIndexOf(log) + 1].includes("Curse") ? logArray[logArray.lastIndexOf(log) + 1].split(" ").slice(2).join(" ") : null
            currentFloor = getFloor(log)
            if (currentCurse) currentFloor.curse = currentCurse
            updateOrCreateRun({trigger: "level init"})
        }
        if(log.includes("generated rooms")) {
            if (!currentRunInit) {
                console.log(log)
                currentRunInit = true
                updateOrCreateRun({trigger: "generated rooms"})
            }
        }
        if(log.split(' ')[2] === "Room") {
            if (!currentGameMode) {
                console.log(log)
                updateOrCreateRun({trigger: "game mode", log: log})
            }
        }
        if(log.includes("Adding collectible")) {
            console.log(log)
            updateOrCreateRun({trigger: "adding collectible", collectible: getCollectible(log, 4)})
            saveFileToDisk(runsJsonPath, JSON.stringify(runs))
        }
        if(log.includes("Removing voided collectible")) {
            console.log(log)
            updateOrCreateRun({trigger: "removing collectible", collectible: getCollectible(log, 5)})
            saveFileToDisk(runsJsonPath, JSON.stringify(runs))
        }
        if(log.includes("Adding trinket")) {
            console.log(log)
            //updateOrCreateRun({trigger: "adding trinket", trinket: getTrinket(log, 4)})
            //saveFileToDisk(runsJsonPath, JSON.stringify(runs))
        }
        if(log.includes("Adding smelted trinket")) {
            console.log(log)
            //updateOrCreateRun({trigger: "adding smelted trinket", trinket: getTrinket(log, 4)})
            //saveFileToDisk(runsJsonPath, JSON.stringify(runs))
        }
        if(log.includes("Game Over") || (log.includes("playing cutscene") && !log.includes("Intro") && !log.includes("Credits") && !log.includes("Dogma"))) {
            console.log(log)
            updateOrCreateRun({trigger: "run end", log: log})
            currentRunInit = false
            currentRun = null
            currentCharater = null
            currentFloor = null
            currentCurse = null
            currentGameMode = null
            saveFileToDisk(runsJsonPath, JSON.stringify(runs))
        }
        if(log.includes("Menu Game Init")) {
            console.log(log)
            inRun = false
            //backToMenu = true
            currentRunInit = false
            currentRun = null
            currentCharater = null
            currentFloor = null
            currentCurse = null
            currentGameMode = null
        }
        //If "Repentance Run Tracker Extended" mod is loaded, parse extra logs lines
        if(log.includes("Lua is resetting!")) {
            console.log(log)
            extendedSaveMode = false
            otherModLoaded = false
            otherModLoaded = false
        }
        if(log.includes("Running Lua Script") && !log.includes("resources/scripts/")) {
            console.log(log)
            if (!config.isaacModFolderPath || config.isaacModFolderPath === "") {
                config.isaacModFolderPath = getModPath(log)
                saveFileToDisk(configJsonPath, JSON.stringify(config))
            }
            if (log.includes("/mods/repentance_run_tracker_extended")) {
                extendedSaveMode = true
            } else {
                otherModLoaded = true
            }
        }
        if(log.includes("[RRTEEXTENDLOGS] Player updated")) {
            console.log(log)
            let playerStats = log.split(" ")[9].replaceAll("=", ":")
            playerStats.replace(/(\w+)\s*:\s*('[^']*'|"[^"]*"|)/gi, (match, match2) => status = status.replace(match2, `"${match2}"`))
            console.log(playerStats)
            if (!extendedSaveMode) {
                extendedSaveMode = true
            }
        }
    })
}

function watchRepentanceLogs() {
    fs.watchFile(repentanceLogsFile,{interval: 500},
        () => {
            const log = fs.readFileSync(repentanceLogsFile, "utf8")
            const logArray = log.split(splitFormat)
            const lines = logArray.filter(v=>v!='').length
            const diff = lines - logsLastReadLines
            if (diff <= 0) return
            const newLogs = logArray.filter(v=>v!='').splice(- diff)
            parseLogs(newLogs, logArray)
            //console.log(diff,logsLastReadLines,lines)
            logsLastReadLines = lines
        }
    )
}

function unWatchRepentanceLogs() {
    fs.unwatchFile(repentanceLogsFile)
}

async function init() {
    const loadRuns = await fileResolve(dataFolder, 'runs.json', '[]') //Load if exist, or creat empty runs.json file
    runs = JSON.parse(fs.readFileSync(loadRuns)) //Set "runs" variable filled with runs.json items
    const loadConfig = await fileResolve(dataFolder, 'config.json', '{}')
    config = JSON.parse(fs.readFileSync(loadConfig))
    currentRunInit = false //Lock update possibilities until a run is launched
    repentanceLogs = fs.readFileSync(repentanceLogsFile, "utf8") //Set "repentanceLogs" variable filled with current Repentance logs
    repentanceLogsArray = repentanceLogs.split(splitFormat) //Split line by line
    extendedSaveMode = repentanceLogsArray.filter(v=>v.includes("RRTE")).length > 0 //Check if the "Repentance Run Tracker Extended" mod was loaded (more logs infos)
    let gameStatesList = repentanceLogsArray.filter(v=>v.includes("Loading GameState"))
    currentGameState = gameStatesList[gameStatesList.length - 1] != undefined ? getGameState(gameStatesList[gameStatesList.length - 1]) : null
    let seedsList = repentanceLogsArray.filter(v=>v.includes("RNG Start Seed"))
    let gameInit = repentanceLogsArray.filter(v=>v.includes("Menu Game Init"))
    if (seedsList[seedsList.length - 1] != undefined) {
        console.log("Seeds exist in current logs, checking...")
        const lastLogs = repentanceLogsArray.slice(findLastIndex(repentanceLogsArray, seedsList[seedsList.length - 1]), repentanceLogsArray.length - 1)
        inRun = lastLogs.filter(v=>v.includes("Menu Game Init")).length < 1 && lastLogs.filter(v=>v.includes("Game Over")).length < 1 && lastLogs.filter(v=>v.includes("playing cutscene")).length < 1
        console.log("Currently in run :", inRun)
        if (inRun) {
            parseLogs(lastLogs, repentanceLogsArray)
        } else {
            const lastLogsOver = repentanceLogsArray.slice(findLastIndex(repentanceLogsArray, gameInit[gameInit.length - 1]), repentanceLogsArray.length - 1)
            parseLogs(lastLogsOver, repentanceLogsArray)
        }
    } else {
        parseLogs(repentanceLogsArray, repentanceLogsArray)
    }
    
    logsLastReadLines = repentanceLogsArray.filter(v=>v!='').length
    if(!firstInit) firstInit = true
    //console.log('init values : ', currentRun, currentCharater, currentFloor)
}


ipcMain.on('IS_APP_READY', (event, payload) => {
    syncApp(win,{trigger: "logs watch status", watching: watchingLogs})
})

//Frontend event, trigger if a run is edited
ipcMain.on('USER_EDIT_RUN', (event, payload) => {
    console.log(payload)
})

//Frontend event, trigger if a run is removed
ipcMain.on('USER_REMOVE_RUN', (event, payload) => {
    console.log(`User wants to remove run : ${payload}`)
    removeRun(payload, runs, runsJsonPath, win)
})

module.exports = {
    startLogsWatch: function(window) {
        win = window
        let wait = false
        setInterval(() => {
            if(!wait) {
                wait = true
                isRunning('isaac-ng.exe', (status) => {
                    if (!status && repentanceIsLaunched) {
                        console.log("unwatch logs")
                        watchingLogs = false
                        repentanceIsLaunched = false
                        unWatchRepentanceLogs()
                        saveFileToDisk(runsJsonPath, JSON.stringify(runs))
                        syncApp(win,{trigger: "logs watch status", watching: false})
                        wait = false
                    } else if (status && !repentanceIsLaunched) {
                        console.log("Waiting for logs...")
                        repentanceIsLaunched = true
                        setTimeout(() => {
                            console.log("Watching logs")
                            watchingLogs = true
                            watchRepentanceLogs()
                            init()
                            repentanceOptions = getOptions(repentanceOptionsFile, splitFormat)
                            console.log(repentanceOptions)
                            syncApp(win,{trigger: "logs watch status", watching: true})
                            wait = false
                        }, 10000)
                    } else {
                        wait = false
                    }
                })
            }
        }, 1000)
    }
}